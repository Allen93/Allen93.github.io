---
title: Kubernetes的设计原则
date: 2017-12-23 15:50:46
tags: Kubernetes
---
### API
* 所有API都是声明式
* 所有对下应该是可组合的，没有不透明的 wrapper
* 控制器透明，没有内部 api
* 所有 api 操作的消耗应该与操作的资源数正比，当心多个 api 操作引起指数消耗
* 对下的状态必须100% 可被观察重现
* 集群范围的不可变量很难保证正确。
* 底层 api 应该被设计为高层的 api 控制。 高层的 api 应该是面向意图，而不是面向实现。

### 控制逻辑
* 功能必须是level-based（基于条件触发），意味着无论有多少中间状态被忽略了， 系统必须根据目标状态和当前状态执行正确的操作。边缘触发只是一个优化。（大概意思是说，不能依赖状态改变的事件操作，而是根据当前状态执行操作）
	* 类 CAP 理论， 在轮询和事件之间找到一个同时满足性能，可靠性，简洁 的取舍平衡
* 假设开放的世界，保持假设 和 并且适应 外部操作行为。 意思是，要能够容忍外部操作。例如手动删除 rc 控制的pod。
* 定义的状态机中， 不要有需要通过 "状态转换操作" 和 "无法被观察者确定的假设状态" 组合才能判断的状态。 意思是状态需要判断明确。
* 组件应该有自愈能力，如果获取错误的数据，或者错过一些事件，它应该能够在不被人感知到的时间内快速修复。

### 架构
* 只有API server 才应该和 etcd 通讯
* 破坏一个节点不应该影响集群
* 所有组件应该在内存中记录所有相关状态。api server应该write through（内存和store同步）到 ETCD，其他组件应该write through到api server。并且他们应该 watch 其他 client 的造成的状态更新
* watch比轮询更好

### Bootstrapping
* 所有组件自运维是一个目标
* 最小依赖，特别是那些需要稳定运行的组件。
* 通过分层的原则，将依赖分层
* 通过将硬依赖转换为软依赖的方式，打破循环依赖
	* 接收其他组件的数据，比如 local file，可以在启动期手动设置，并且被其他模块更新
	* 状态可以被重新发现，或者重置
	* 所有组件可以运行临时的初始化实例
	* 可以重启挂掉的组件。分布式组件，可以使用replication。 本地组件，一个进程管理或者内胆的巡检脚本即可。

### 文档
https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/principles.md